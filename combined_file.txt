// src/graph.rs

use cxx::UniquePtr;
use std::fmt;

// `super` refers to the parent module (src/lib.rs) and allows us to
// access the private `ffi` module from within our crate.
use super::ffi;

/// A custom error type for operations within the odgi-ffi crate.
#[derive(Debug)]
pub struct Error(String);

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A safe, idiomatic Rust wrapper around a C++ `odgi::graph_t` object.
///
/// The `Graph` struct manages the lifetime of the underlying C++ graph object.
/// When it is dropped, the C++ object is automatically deallocated.
pub struct Graph {
    // This field is private. It holds the pointer to our C++ OpaqueGraph wrapper.
    inner: UniquePtr<ffi::OpaqueGraph>,
}

impl Graph {
    /// Loads an ODGI graph from a file.
    ///
    /// # Arguments
    ///
    /// * `path` - A string slice that holds the path to the `.odgi` file.
    ///
    /// # Errors
    ///
    /// Returns an `Error` if the C++ backend fails to load the graph, for example
    /// if the file does not exist or is corrupted.
    pub fn load(path: &str) -> Result<Self, Error> {
        // Unsafe FFI call is encapsulated here.
        let graph_ptr = ffi::load_graph(path);

        if graph_ptr.is_null() {
            Err(Error(format!("Failed to load ODGI graph from '{}'", path)))
        } else {
            Ok(Graph { inner: graph_ptr })
        }
    }

    /// Returns the number of nodes in the graph.
    pub fn node_count(&self) -> u64 {
        // This safe method hides the chain of unsafe FFI calls.
        let opaque_graph_ref = &self.inner;
        let graph_t_ref = ffi::get_graph_t(opaque_graph_ref);
        ffi::get_node_count(graph_t_ref)
    }
}// src/lib.rs

// 1. Declare the `graph` module, which corresponds to `src/graph.rs`.
mod graph;

// 2. Re-export the public items from the `graph` module so users can easily
// access them with `use odgi_ffi::Graph;`.
pub use graph::{Graph, Error};


// 3. The FFI bridge is a private implementation detail of this crate.
// Users will not and cannot access this directly.
#[cxx::bridge(namespace = "odgi")]
mod ffi {
    unsafe extern "C++" {
        include!("odgi.hpp");
        include!("odgi-ffi/src/odgi_wrapper.hpp");
        
        // This type is correctly found in the `odgi` namespace.
        type graph_t;

        // The following types and functions are in the global C++ namespace.
        #[namespace = ""]
        type OpaqueGraph;

        #[namespace = ""]
        fn load_graph(path: &str) -> UniquePtr<OpaqueGraph>;

        #[namespace = ""]
        fn get_graph_t<'a>(graph: &'a OpaqueGraph) -> &'a graph_t;

        // CORRECTED: This function also lives in the global namespace, so it needs
        // the attribute to override the module-level `namespace = "odgi"`.
        #[namespace = ""]
        fn get_node_count(graph: &graph_t) -> u64;
    }
}// src/odgi.cpp

#include "odgi_wrapper.hpp"
#include <fstream>
#include <string>
#include "odgi-ffi/src/lib.rs.h"

std::unique_ptr<OpaqueGraph> load_graph(rust::Str path) {
    auto odgi_graph = std::make_unique<odgi::graph_t>();
    std::ifstream in{std::string(path)};

    if (!in) {
        return nullptr;
    }
    odgi_graph->deserialize(in);

    auto wrapper = std::make_unique<OpaqueGraph>();
    wrapper->graph = std::move(odgi_graph);
    return wrapper;
}

const odgi::graph_t& get_graph_t(const OpaqueGraph& wrapper) {
    return *wrapper.graph.get();
}

uint64_t get_node_count(const odgi::graph_t& graph) {
    return graph.get_node_count();
}// src/odgi_wrapper.hpp

#pragma once
#include "odgi.hpp"
#include "rust/cxx.h"
#include <memory>

struct OpaqueGraph {
    std::unique_ptr<odgi::graph_t> graph;
};

std::unique_ptr<OpaqueGraph> load_graph(rust::Str path);
const odgi::graph_t& get_graph_t(const OpaqueGraph& graph);
uint64_t get_node_count(const odgi::graph_t& graph);